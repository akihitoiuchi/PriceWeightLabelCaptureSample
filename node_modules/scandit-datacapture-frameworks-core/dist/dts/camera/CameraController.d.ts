import EventEmitter from "eventemitter3";
import { Camera } from "./Camera";
import { FrameData, FrameSourceState } from "../frame";
import { CameraPosition } from "../camerahelpers";
import { NativeCallResult } from "../common";
import { BaseNewController } from "../controllers/BaseNewController";
export interface CameraProxy {
    $getCurrentCameraState({ position }: {
        position: CameraPosition;
    }): Promise<NativeCallResult>;
    $switchCameraToDesiredState({ desiredStateJson }: {
        desiredStateJson: string;
    }): Promise<void>;
    $isTorchAvailable({ position }: {
        position: CameraPosition;
    }): Promise<NativeCallResult>;
    $registerListenerForCameraEvents(): void;
    $unregisterListenerForCameraEvents(): Promise<void>;
    $getFrame({ frameId }: {
        frameId: string;
    }): Promise<NativeCallResult | null>;
    subscribeForEvents(events: string[]): void;
    unsubscribeFromEvents(events: string[]): void;
    dispose(): void;
    eventEmitter: EventEmitter;
}
export declare class CameraController extends BaseNewController<CameraProxy> {
    private camera;
    private static get _proxy();
    static forCamera(camera: Camera): CameraController;
    private constructor();
    private get privateCamera();
    static getFrame(frameId: string): Promise<FrameData>;
    static getFrameOrNull(frameId: string): Promise<FrameData | null>;
    getCurrentState(): Promise<FrameSourceState>;
    getIsTorchAvailable(): Promise<boolean>;
    switchCameraToDesiredState(desiredState: FrameSourceState): Promise<void>;
    subscribeListener(): void;
    unsubscribeListener(): void;
    dispose(): void;
    private handleDidChangeStateEvent;
}
